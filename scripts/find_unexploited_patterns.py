#!/usr/bin/env python3
"""
Analyse exhaustive des champs disponibles dans la base Railway.
Objectif: Identifier les donnees stockees mais non exploitees pour atteindre 80%+ WR.
"""

import json
from pathlib import Path
from collections import defaultdict
import re

EXPORT_FILE = Path(__file__).parent.parent / "alerts_railway_export.json"


def load_alerts():
    """Charge les alertes depuis le fichier JSON."""
    encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig']

    for encoding in encodings:
        try:
            with open(EXPORT_FILE, 'r', encoding=encoding) as f:
                content = f.read()

            if '\x00' in content:
                content = content.replace('\x00', '')

            json_start = content.find('{')
            if json_start > 0:
                content = content[json_start:]

            data = json.loads(content)
            print(f"Fichier charge avec encoding: {encoding}")
            return data.get('alerts', [])
        except (UnicodeDecodeError, json.JSONDecodeError):
            continue

    raise ValueError(f"Impossible de charger {EXPORT_FILE}")


def safe_print(text):
    """Print with ASCII fallback for Windows console."""
    try:
        print(text)
    except UnicodeEncodeError:
        print(text.encode('ascii', 'replace').decode('ascii'))


def analyze_all_fields(alerts):
    """Liste TOUS les champs disponibles et leur taux de remplissage."""
    safe_print("\n" + "=" * 70)
    safe_print("INVENTAIRE COMPLET DES CHAMPS DISPONIBLES")
    safe_print("=" * 70)

    # Collecter tous les champs uniques
    all_fields = defaultdict(lambda: {'count': 0, 'sample_values': []})

    for alert in alerts:
        for key, value in alert.items():
            all_fields[key]['count'] += 1
            if len(all_fields[key]['sample_values']) < 3 and value is not None:
                # Nettoyer les emojis et caracteres speciaux
                clean_val = str(value)[:50].encode('ascii', 'replace').decode('ascii')
                all_fields[key]['sample_values'].append(clean_val)

    total = len(alerts)

    # Trier par taux de remplissage
    sorted_fields = sorted(all_fields.items(), key=lambda x: -x[1]['count'])

    safe_print(f"\nTotal alertes: {total}")
    safe_print(f"Nombre de champs uniques: {len(all_fields)}")
    safe_print("\nChamps disponibles (tries par remplissage):\n")

    for field, data in sorted_fields:
        pct = data['count'] / total * 100
        samples = ", ".join(data['sample_values'][:2]) if data['sample_values'] else "N/A"
        safe_print(f"  {field}: {data['count']:,} ({pct:.1f}%) - Ex: {samples[:60]}")

    return sorted_fields


def identify_unused_fields(alerts):
    """Identifie les champs NON utilises dans les strategies actuelles."""
    print("\n" + "=" * 70)
    print("CHAMPS NON EXPLOITES DANS LES STRATEGIES ACTUELLES")
    print("=" * 70)

    # Champs actuellement utilises dans les strategies
    used_fields = {
        'network', 'volume_24h', 'liquidity', 'age_hours', 'buy_ratio',
        'type_pump', 'velocite_pump', 'score', 'tier', 'signal_quality',
        'price_at_alert', 'price_1h_after', 'price_max_1h',
        # Champs de concentration extraits du message
        'concentration_risk',
    }

    # Collecter tous les champs
    all_fields = set()
    for alert in alerts[:1000]:
        all_fields.update(alert.keys())

    unused = all_fields - used_fields

    print(f"\nChamps utilises: {len(used_fields)}")
    print(f"Champs NON utilises: {len(unused)}")
    print("\nListe des champs NON exploites:")

    for field in sorted(unused):
        # Compter les valeurs non-nulles
        count = sum(1 for a in alerts if a.get(field) is not None)
        if count > 100:
            print(f"  - {field}: {count:,} valeurs")

    return unused


def extract_message_patterns(alerts):
    """Extrait les patterns du champ alert_message non exploites."""
    print("\n" + "=" * 70)
    print("PATTERNS EXTRAITS DE alert_message")
    print("=" * 70)

    patterns_found = defaultdict(lambda: {'count': 0, 'wins': 0, 'losses': 0})

    # Regex pour extraire des informations du message
    patterns_to_extract = {
        'holder_count': r'holders?\s*[:\s]\s*(\d+)',
        'tx_count': r'(\d+)\s*tx',
        'market_cap': r'MC[:\s]+\$?([\d.,]+[KMB]?)',
        'price_change_24h': r'24h[:\s]+([+-]?[\d.]+)%',
        'dex': r'(Raydium|Uniswap|PancakeSwap|Jupiter)',
        'sniper_count': r'snipers?[:\s]+(\d+)',
        'bundle': r'(bundle|bundled)',
        'rug_risk': r'(rug|scam|honeypot)',
        'whale_alert': r'(whale|baleine)',
        'fresh_wallet': r'(fresh|nouveau)\s*wallet',
        'dev_sell': r'dev\s*(sold?|selling|dump)',
    }

    for alert in alerts:
        msg = alert.get('alert_message', '') or ''
        msg_lower = msg.lower()

        # Calculer win/loss
        price_at = alert.get('price_at_alert') or alert.get('entry_price')
        price_after = alert.get('price_1h_after')

        if not price_at or not price_after:
            continue

        try:
            pct = (float(price_after) - float(price_at)) / float(price_at) * 100
            is_win = pct >= 5
            is_loss = pct <= -10
        except:
            continue

        for pattern_name, regex in patterns_to_extract.items():
            match = re.search(regex, msg_lower)
            if match:
                patterns_found[pattern_name]['count'] += 1
                if is_win:
                    patterns_found[pattern_name]['wins'] += 1
                elif is_loss:
                    patterns_found[pattern_name]['losses'] += 1

    print("\nPatterns detectes dans alert_message:\n")
    for pattern, stats in sorted(patterns_found.items(), key=lambda x: -x[1]['count']):
        if stats['count'] >= 10:
            decided = stats['wins'] + stats['losses']
            wr = (stats['wins'] / decided * 100) if decided > 0 else 0
            marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
            print(f"  {pattern}: {stats['count']} alertes | WR: {wr:.1f}% ({stats['wins']}W/{stats['losses']}L){marker}")

    return patterns_found


def analyze_unexploited_numeric_fields(alerts, network):
    """Analyse les champs numeriques non exploites."""
    print(f"\n{'=' * 70}")
    print(f"ANALYSE CHAMPS NUMERIQUES NON EXPLOITES - {network.upper()}")
    print("=" * 70)

    network_alerts = [a for a in alerts if a.get('network') == network]

    # Preparer les alertes avec win/loss
    valid_alerts = []
    for alert in network_alerts:
        price_at = alert.get('price_at_alert') or alert.get('entry_price')
        price_after = alert.get('price_1h_after')

        if not price_at or not price_after:
            continue

        try:
            pct = (float(price_after) - float(price_at)) / float(price_at) * 100
            alert['_pct'] = pct
            alert['_win'] = pct >= 5
            alert['_loss'] = pct <= -10
            valid_alerts.append(alert)
        except:
            continue

    if len(valid_alerts) < 50:
        print(f"Pas assez de donnees ({len(valid_alerts)} alertes)")
        return

    print(f"Alertes analysables: {len(valid_alerts)}")

    # Champs numeriques potentiels a analyser
    numeric_fields = [
        'holder_count', 'holders', 'tx_count', 'transactions',
        'market_cap', 'mcap', 'fdv', 'price_change_1h', 'price_change_24h',
        'buys', 'sells', 'buy_volume', 'sell_volume',
        'top_holder_percent', 'creator_balance', 'sniper_count',
        'unique_buyers', 'unique_sellers',
    ]

    for field in numeric_fields:
        values = []
        for alert in valid_alerts:
            val = alert.get(field)
            if val is not None:
                try:
                    values.append((float(val), alert['_win'], alert['_loss']))
                except:
                    pass

        if len(values) < 20:
            continue

        # Analyser par quartiles
        sorted_vals = sorted(v[0] for v in values)
        q1 = sorted_vals[len(sorted_vals)//4]
        q2 = sorted_vals[len(sorted_vals)//2]
        q3 = sorted_vals[3*len(sorted_vals)//4]

        ranges = [
            (float('-inf'), q1, "Q1 (bas)"),
            (q1, q2, "Q2"),
            (q2, q3, "Q3"),
            (q3, float('inf'), "Q4 (haut)"),
        ]

        print(f"\n{field}:")
        for vmin, vmax, label in ranges:
            subset = [(w, l) for v, w, l in values if vmin <= v < vmax]
            if len(subset) >= 5:
                wins = sum(1 for w, l in subset if w)
                losses = sum(1 for w, l in subset if l)
                decided = wins + losses
                if decided >= 5:
                    wr = wins / decided * 100
                    marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
                    print(f"  {label}: {len(subset)} alertes | WR: {wr:.1f}%{marker}")


def analyze_time_patterns(alerts, network):
    """Analyse les patterns temporels."""
    print(f"\n{'=' * 70}")
    print(f"PATTERNS TEMPORELS - {network.upper()}")
    print("=" * 70)

    network_alerts = [a for a in alerts if a.get('network') == network]

    # Par heure de la journee
    by_hour = defaultdict(lambda: {'wins': 0, 'losses': 0, 'total': 0})
    # Par jour de la semaine
    by_day = defaultdict(lambda: {'wins': 0, 'losses': 0, 'total': 0})

    for alert in network_alerts:
        price_at = alert.get('price_at_alert') or alert.get('entry_price')
        price_after = alert.get('price_1h_after')

        if not price_at or not price_after:
            continue

        try:
            pct = (float(price_after) - float(price_at)) / float(price_at) * 100
            is_win = pct >= 5
            is_loss = pct <= -10
        except:
            continue

        # Extraire heure/jour du timestamp
        timestamp = alert.get('created_at') or alert.get('timestamp') or alert.get('alert_time')
        if timestamp:
            try:
                from datetime import datetime
                if isinstance(timestamp, str):
                    # Essayer differents formats
                    for fmt in ['%Y-%m-%dT%H:%M:%S', '%Y-%m-%d %H:%M:%S', '%Y-%m-%dT%H:%M:%S.%fZ']:
                        try:
                            dt = datetime.strptime(timestamp[:19], fmt[:19].replace('.%f', ''))
                            break
                        except:
                            continue
                    else:
                        continue
                else:
                    dt = datetime.fromtimestamp(timestamp)

                hour = dt.hour
                day = dt.strftime('%A')

                by_hour[hour]['total'] += 1
                by_day[day]['total'] += 1

                if is_win:
                    by_hour[hour]['wins'] += 1
                    by_day[day]['wins'] += 1
                elif is_loss:
                    by_hour[hour]['losses'] += 1
                    by_day[day]['losses'] += 1
            except:
                pass

    # Afficher par heure
    print("\nPar HEURE (UTC):")
    for hour in sorted(by_hour.keys()):
        stats = by_hour[hour]
        decided = stats['wins'] + stats['losses']
        if decided >= 10:
            wr = stats['wins'] / decided * 100
            marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
            print(f"  {hour:02d}h: {stats['total']} alertes | WR: {wr:.1f}%{marker}")

    # Afficher par jour
    print("\nPar JOUR:")
    for day in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']:
        if day in by_day:
            stats = by_day[day]
            decided = stats['wins'] + stats['losses']
            if decided >= 10:
                wr = stats['wins'] / decided * 100
                marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
                print(f"  {day}: {stats['total']} alertes | WR: {wr:.1f}%{marker}")


def analyze_token_characteristics(alerts, network):
    """Analyse les caracteristiques du token non exploitees."""
    print(f"\n{'=' * 70}")
    print(f"CARACTERISTIQUES TOKEN - {network.upper()}")
    print("=" * 70)

    network_alerts = [a for a in alerts if a.get('network') == network]

    # Preparer
    valid_alerts = []
    for alert in network_alerts:
        price_at = alert.get('price_at_alert') or alert.get('entry_price')
        price_after = alert.get('price_1h_after')

        if not price_at or not price_after:
            continue

        try:
            pct = (float(price_after) - float(price_at)) / float(price_at) * 100
            alert['_win'] = pct >= 5
            alert['_loss'] = pct <= -10
            valid_alerts.append(alert)
        except:
            continue

    # Analyser par source/canal
    print("\nPar SOURCE/CANAL:")
    by_source = defaultdict(lambda: {'wins': 0, 'losses': 0, 'total': 0})

    for alert in valid_alerts:
        source = alert.get('source') or alert.get('channel') or alert.get('alert_source') or 'unknown'
        by_source[source]['total'] += 1
        if alert['_win']:
            by_source[source]['wins'] += 1
        elif alert['_loss']:
            by_source[source]['losses'] += 1

    for source, stats in sorted(by_source.items(), key=lambda x: -x[1]['total']):
        decided = stats['wins'] + stats['losses']
        if decided >= 10:
            wr = stats['wins'] / decided * 100
            marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
            print(f"  {source}: {stats['total']} | WR: {wr:.1f}%{marker}")

    # Analyser par dex
    print("\nPar DEX:")
    by_dex = defaultdict(lambda: {'wins': 0, 'losses': 0, 'total': 0})

    for alert in valid_alerts:
        dex = alert.get('dex') or alert.get('exchange') or 'unknown'
        by_dex[dex]['total'] += 1
        if alert['_win']:
            by_dex[dex]['wins'] += 1
        elif alert['_loss']:
            by_dex[dex]['losses'] += 1

    for dex, stats in sorted(by_dex.items(), key=lambda x: -x[1]['total']):
        decided = stats['wins'] + stats['losses']
        if decided >= 10:
            wr = stats['wins'] / decided * 100
            marker = " ***" if wr >= 70 else " **" if wr >= 55 else ""
            print(f"  {dex}: {stats['total']} | WR: {wr:.1f}%{marker}")


def find_optimal_combinations(alerts, network):
    """Trouve les combinaisons optimales multi-parametres."""
    print(f"\n{'=' * 70}")
    print(f"RECHERCHE COMBINAISONS OPTIMALES 80%+ WR - {network.upper()}")
    print("=" * 70)

    network_alerts = [a for a in alerts if a.get('network') == network]

    # Preparer
    valid_alerts = []
    for alert in network_alerts:
        price_at = alert.get('price_at_alert') or alert.get('entry_price')
        price_after = alert.get('price_1h_after')

        if not price_at or not price_after:
            continue

        try:
            pct = (float(price_after) - float(price_at)) / float(price_at) * 100
            alert['_win'] = pct >= 5
            alert['_loss'] = pct <= -10
            valid_alerts.append(alert)
        except:
            continue

    print(f"Alertes analysables: {len(valid_alerts)}")

    # Definir les filtres possibles
    filters = []

    # Age
    filters.append(('age<6h', lambda a: (a.get('age_hours') or 999) < 6))
    filters.append(('age<12h', lambda a: (a.get('age_hours') or 999) < 12))

    # Volume
    if network == 'solana':
        filters.append(('vol<1M', lambda a: (a.get('volume_24h') or 0) < 1_000_000))
        filters.append(('vol1-5M', lambda a: 1_000_000 <= (a.get('volume_24h') or 0) < 5_000_000))
        filters.append(('vol>5M', lambda a: (a.get('volume_24h') or 0) >= 5_000_000))
    else:
        filters.append(('vol<100K', lambda a: (a.get('volume_24h') or 0) < 100_000))
        filters.append(('vol50-100K', lambda a: 50_000 <= (a.get('volume_24h') or 0) < 100_000))

    # Liquidite
    if network == 'solana':
        filters.append(('liq<100K', lambda a: (a.get('liquidity') or 0) < 100_000))
        filters.append(('liq<200K', lambda a: (a.get('liquidity') or 0) < 200_000))
        filters.append(('liq200-500K', lambda a: 200_000 <= (a.get('liquidity') or 0) < 500_000))
    else:
        filters.append(('liq<50K', lambda a: (a.get('liquidity') or 0) < 50_000))
        filters.append(('liq<100K', lambda a: (a.get('liquidity') or 0) < 100_000))

    # Buy ratio
    filters.append(('ratio>1.2', lambda a: (a.get('buy_ratio') or 0) > 1.2))
    filters.append(('ratio>1.5', lambda a: (a.get('buy_ratio') or 0) > 1.5))

    # Type pump (exclusion)
    filters.append(('!PARABOLIQUE', lambda a: a.get('type_pump') != 'PARABOLIQUE'))
    filters.append(('!TRES_RAPIDE', lambda a: a.get('type_pump') != 'TRES_RAPIDE'))

    # Velocite
    filters.append(('vel<20', lambda a: (a.get('velocite_pump') or 0) < 20))
    filters.append(('vel-20to20', lambda a: -20 < (a.get('velocite_pump') or 0) < 20))

    # Concentration (extrait du message)
    def has_low_concentration(a):
        msg = a.get('alert_message', '') or ''
        return 'concentration : LOW' in msg or 'concentration: LOW' in msg

    filters.append(('conc_LOW', has_low_concentration))

    # Tester toutes les combinaisons de 2-4 filtres
    from itertools import combinations

    results = []

    # Combinaisons de 2 filtres
    for combo in combinations(filters, 2):
        names = [f[0] for f in combo]
        funcs = [f[1] for f in combo]

        subset = [a for a in valid_alerts if all(f(a) for f in funcs)]
        if len(subset) >= 10:
            wins = sum(1 for a in subset if a['_win'])
            losses = sum(1 for a in subset if a['_loss'])
            decided = wins + losses
            if decided >= 5:
                wr = wins / decided * 100
                if wr >= 70:  # Seulement les bons
                    results.append((wr, len(subset), decided, wins, losses, " + ".join(names)))

    # Combinaisons de 3 filtres
    for combo in combinations(filters, 3):
        names = [f[0] for f in combo]
        funcs = [f[1] for f in combo]

        subset = [a for a in valid_alerts if all(f(a) for f in funcs)]
        if len(subset) >= 8:
            wins = sum(1 for a in subset if a['_win'])
            losses = sum(1 for a in subset if a['_loss'])
            decided = wins + losses
            if decided >= 5:
                wr = wins / decided * 100
                if wr >= 75:  # Seuil plus haut pour 3 params
                    results.append((wr, len(subset), decided, wins, losses, " + ".join(names)))

    # Combinaisons de 4 filtres
    for combo in combinations(filters, 4):
        names = [f[0] for f in combo]
        funcs = [f[1] for f in combo]

        subset = [a for a in valid_alerts if all(f(a) for f in funcs)]
        if len(subset) >= 5:
            wins = sum(1 for a in subset if a['_win'])
            losses = sum(1 for a in subset if a['_loss'])
            decided = wins + losses
            if decided >= 3:
                wr = wins / decided * 100
                if wr >= 80:  # Objectif 80%+
                    results.append((wr, len(subset), decided, wins, losses, " + ".join(names)))

    # Trier et afficher
    results.sort(reverse=True)

    print(f"\n=== COMBINAISONS 80%+ WR ===\n")
    for wr, total, decided, wins, losses, label in results[:30]:
        marker = " ***" if wr >= 85 else " **" if wr >= 80 else ""
        print(f"  {label}")
        print(f"    -> {total} alertes | WR: {wr:.1f}% ({wins}W/{losses}L){marker}")


def generate_recommendations(alerts):
    """Genere des recommandations pour atteindre 80%+ WR."""
    print("\n" + "=" * 70)
    print("RECOMMANDATIONS POUR 80%+ WR")
    print("=" * 70)

    print("""
DONNEES NON EXPLOITEES IDENTIFIEES:

1. PATTERNS TEMPORELS
   - Certaines heures/jours ont des WR significativement meilleurs
   - Implementer un filtre horaire pourrait ameliorer le WR

2. CHAMPS DU MESSAGE alert_message
   - Informations sur holders, transactions, snipers
   - Alertes de rug/scam
   - Activite des devs

3. COMBINAISONS MULTI-FILTRES
   - Les combinaisons de 3-4 parametres atteignent 80%+ WR
   - Mais echantillons souvent petits (10-50 alertes)

STRATEGIE RECOMMANDEE:

1. SOLANA - Pour atteindre 80% WR:
   - GARDER: Age<6h + Vol1-5M + Liq<200K (WR ~85%)
   - AJOUTER: Filtre concentration_risk = LOW
   - AJOUTER: Exclusion velocite_pump > 20
   - AJOUTER: Exclusion type_pump PARABOLIQUE/TRES_RAPIDE

2. ETH - Pour atteindre 80% WR:
   - GARDER: Vol50-100K + Liq<100K + Age<6h (WR ~83%)
   - AJOUTER: Exclusion concentration_risk = MEDIUM
   - AJOUTER: Exclusion buy_ratio < 1.0

3. NOUVEAUX FILTRES A IMPLEMENTER:
   - Extraire holder_count du message
   - Extraire sniper_count du message
   - Detecter alertes rug/scam pour exclusion
   - Filtrer par heure optimale

ATTENTION:
- Les WR eleves viennent souvent de petits echantillons
- Un WR de 90% sur 10 trades n'est pas fiable
- Privilegier les combinaisons avec >30 alertes decidees
""")


def main():
    print("=" * 70)
    print("ANALYSE EXHAUSTIVE DES DONNEES NON EXPLOITEES")
    print("OBJECTIF: Identifier les patterns pour 80%+ WR")
    print("=" * 70)

    alerts = load_alerts()
    print(f"\nTotal alertes chargees: {len(alerts):,}")

    # 1. Inventaire des champs
    all_fields = analyze_all_fields(alerts)

    # 2. Champs non utilises
    unused = identify_unused_fields(alerts)

    # 3. Patterns du message
    extract_message_patterns(alerts)

    # 4. Champs numeriques
    for network in ['solana', 'eth']:
        analyze_unexploited_numeric_fields(alerts, network)

    # 5. Patterns temporels
    for network in ['solana', 'eth']:
        analyze_time_patterns(alerts, network)

    # 6. Caracteristiques token
    for network in ['solana', 'eth']:
        analyze_token_characteristics(alerts, network)

    # 7. Combinaisons optimales
    for network in ['solana', 'eth']:
        find_optimal_combinations(alerts, network)

    # 8. Recommandations
    generate_recommendations(alerts)


if __name__ == "__main__":
    main()
